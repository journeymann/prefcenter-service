/**
 * 
 */
package com.fd.epcws.swagger;

import com.fd.epcws.constants.Constants;
import com.fd.epcws.util.helpers.LoggingHelper;
import com.wordnik.swagger.annotations.ApiModelProperty;
import com.wordnik.swagger.converter.SwaggerSchemaConverter;
import com.wordnik.swagger.model.Model;
import scala.Option;
import scala.collection.immutable.Map;

import javax.xml.bind.annotation.XmlElement;

import org.apache.logging.log4j.Logger;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;

/**
 * Applies application specific rules to the model generated by Swagger.
 * <p/>
 * Processes all methods annotated with ApiModelProperty. Supports discovering the field name from the XmlElement annotation if present
 * otherwise uses bean introspection to determine the field name.
 * <p/>
 * Applies the following rules:
 * <p/>
 * <ul>
 * <li>Hides model properties that have methods annotated with ApiModelProperty(access = "hidden")</li>
 * </ul>
 *
 * @author cgordon
 */
public class CustomModelConverter extends SwaggerSchemaConverter {

	private final String CLASSNAME = "CustomModelConverter";
	private static Logger LOGGER = LoggingHelper.getLogger(CustomModelConverter.class);

	/** This is a convenience method to ensure an interface exists for a two param function call.
	 * @param  <code>Class</code> Scala model class   
	 * @param  <code>Map</code> map of class/model types 
	 * @return <code>Option</code> Scala option object containing the Model objects
	 */	
	public Option<Model> read(Class<?> modelClass, Map<String, String> typeMap) {
		String METHODNAME = "read OL1";
		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_CALLED_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));

		return this.read(modelClass);
	}

	/** This is method reads the json i/o data and returns a scala Option object
	 * @param  <code>Class</code> Scala model class   
	 * @return <code>Option</code> Scala model object 
	 */	
	public Option<Model> read(Class<?> modelClass) {
		String METHODNAME = "read OL2";
		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_ENTER_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));

		Option<Model> modelOption = super.read(modelClass);

		Class<?> currentClass = modelClass;

		while (currentClass.getSuperclass() != null) {
			for (Method method : modelClass.getDeclaredMethods()) {
				processApiModelPropertyMethods(currentClass, method, modelOption);
			}
			currentClass = currentClass.getSuperclass();
		}

		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_EXIT_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));        
		return modelOption;
	}

	/** This is a convenience method to ensure an interface exists for a two param function call.
	 * 
	 * Please note that logging is not maintained for this method because it is being called too frequently and was 
	 * cluttering up the log file.
	 * 
	 * @param  <code>Class</code> current class being processed for swagger processing   
	 * @param  <code>Method</code> current method 
	 * @param <code>Option</code> Scala model object
	 */	
	private void processApiModelPropertyMethods(Class<?> currentClass, Method method, Option<Model> modelOption) {

		try {
			if (method.isAnnotationPresent(ApiModelProperty.class)) {
				hideFieldsWithHiddenAccess(currentClass, method, modelOption);
			}
		} catch (SecurityException e) {
			LOGGER.error(Constants.MESSAGE_ERROR_FAIL_GET_PROCESS_METHOD,e);
		}
       
	}

	/** This is method performs the task of hiding the fields marked as hidden in the ApiModelProperty annotation
	 * @param  <code>Class</code> current class being processed for swagger processing   
	 * @param  <code>Method</code> current method 
	 * @param <code>Option</code> Scala model object
	 */	
	private void hideFieldsWithHiddenAccess(Class<?> currentClass, Method method, Option<Model> modelOption) {

		String METHODNAME = "hideFieldsWithHiddenAccess";
		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_ENTER_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));

		if (!method.getAnnotation(ApiModelProperty.class).access().isEmpty() && method.getAnnotation(ApiModelProperty.class).access().equals("hidden")) {
			String fieldName;
			if (method.isAnnotationPresent(XmlElement.class) && !method.getAnnotation(XmlElement.class).name().isEmpty()) {
				fieldName = method.getAnnotation(XmlElement.class).name();
			} else {
				fieldName = getFieldNameFromMethod(currentClass, method);
			}
			if (fieldName != null) {
				modelOption.get().properties().remove(fieldName);
			}
		}

		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_EXIT_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));        
	}

	/** This is method determines the field name by inspecting the method name
	 * @param  <code>Class</code> current class being processed for swagger processing   
	 * @param  <code>Method</code> current method 
	 * @return <code>String</code> Calculated fuield name
	 */	
	private String getFieldNameFromMethod(Class<?> currentClass, Method method) {
		String METHODNAME = "getFieldNameFromMethod";
		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_ENTER_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));

		try {
			for (PropertyDescriptor propertyDescriptor : Introspector.getBeanInfo(currentClass).getPropertyDescriptors()) {
				if (propertyDescriptor.getReadMethod().getName().equals(method.getName())) {
					return propertyDescriptor.getName();
				}
			}
		} catch (IntrospectionException e) {
			LOGGER.error(Constants.MESSAGE_ERROR_FAIL_GET_FIELD_NAME,e);
		}

		LOGGER.debug(String.format(Constants.MESSAGE_DEBUG_EXIT_FUNCTION_INCLUDE,CLASSNAME, METHODNAME));        
		return null;
	}
}